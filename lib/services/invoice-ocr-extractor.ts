/**
 * ü§ñ SERVICE D'EXTRACTION DE DONN√âES DE FACTURES
 * 
 * Workflow d'extraction SIMPLIFI√â et ROBUSTE :
 * 1. Upload le PDF vers OpenAI Files API
 * 2. Utilise GPT-4o pour lire et extraire les donn√©es directement du PDF
 * 3. Retourne les donn√©es structur√©es avec score de confiance
 * 
 * Compatible avec Next.js (pas de workers, pas de binaires natifs)
 */

import OpenAI from 'openai';
import fs from 'fs';
import path from 'path';
import os from 'os';

export interface ExtractedInvoiceData {
  // Informations principales
  invoice_number: string | null;
  vendor_name: string | null;
  category: string | null; // Cat√©gorie comptable
  invoice_date: string | null; // Format ISO: YYYY-MM-DD
  due_date: string | null;
  
  // Montants
  total_amount: number | null;
  subtotal: number | null;
  tax_amount: number | null;
  tax_rate: number | null;
  currency: string | null;
  
  // Coordonn√©es fournisseur (√©metteur de la facture)
  vendor_address: string | null;
  vendor_city: string | null;
  vendor_country: string | null;
  vendor_phone: string | null;
  vendor_email: string | null;
  vendor_website: string | null;
  
  // Coordonn√©es client (destinataire de la facture)
  customer_name: string | null;
  customer_address: string | null;
  customer_city: string | null;
  customer_country: string | null;
  customer_phone: string | null;
  customer_email: string | null;
  customer_vat_number: string | null; // Num√©ro de TVA du client
  
  // Paiement
  payment_status: 'paid' | 'unpaid' | 'pending' | 'overdue' | null;
  payment_method: string | null;
  payment_date: string | null;
  
  // Lignes de facture
  line_items: Array<{
    description: string;
    quantity: number;
    unit_price: number;
    total: number;
  }> | null;
  
  // üé® LOGO (NOUVEAU !)
  vendor_logo_description: string | null; // Description du logo pour identification
  vendor_logo_colors: string[] | null; // Couleurs principales du logo
  vendor_logo_text: string | null; // Texte visible dans le logo
  
  // üîç CLASSIFICATION DU DOCUMENT (NOUVEAU !)
  document_type: 'invoice' | 'receipt' | 'terms_and_conditions' | 'pricing_sheet' | 'notification' | 'contract' | 'other' | null;
  
  // M√©tadonn√©es d'extraction
  extraction_status: 'success' | 'partial' | 'failed';
  confidence_score: number; // 0-100%
  ocr_text: string; // Texte brut extrait par OCR
}

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Upload un PDF vers OpenAI et extrait les donn√©es avec GPT-4o
 */
async function extractDataDirectlyFromPDF(
  pdfBuffer: Buffer,
  emailContext?: { from: string; subject: string; date: string }
): Promise<Partial<ExtractedInvoiceData>> {
  console.log('üì§ [GPT-4o] Upload du PDF vers OpenAI...');
  
  try {
    // Cr√©er un fichier temporaire
    const tempDir = os.tmpdir();
    const tempFilePath = path.join(tempDir, `invoice-${Date.now()}.pdf`);
    fs.writeFileSync(tempFilePath, pdfBuffer);
    
    // Upload vers OpenAI Files API
    const file = await openai.files.create({
      file: fs.createReadStream(tempFilePath),
      purpose: 'assistants',
    });
    
    console.log(`‚úÖ [GPT-4o] PDF upload√©: ${file.id}`);
    
    // Nettoyer le fichier temporaire
    fs.unlinkSync(tempFilePath);
    
    // Cr√©er un assistant temporaire pour lire le PDF
    const assistant = await openai.beta.assistants.create({
      name: 'Invoice Data Extractor',
      instructions: 'Tu es un expert comptable. Tu extrais les donn√©es de factures au format JSON.',
      model: 'gpt-4o',
      tools: [{ type: 'file_search' }],
    });
    
    // Cr√©er un thread avec le fichier
    const thread = await openai.beta.threads.create({
      messages: [
        {
          role: 'user',
          content: `Analyse cette facture PDF et extrait TOUTES les donn√©es au format JSON.

${emailContext ? `CONTEXTE EMAIL:
- De: ${emailContext.from}
- Sujet: ${emailContext.subject}
- Date: ${emailContext.date}
` : ''}

IMPORTANT : 
1. **IDENTIFIE D'ABORD LE TYPE DE DOCUMENT** (voir ci-dessous)
2. Analyse le LOGO du fournisseur en haut du document et d√©cris-le pr√©cis√©ment.
3. Si c'est une facture/re√ßu, cat√©gorise selon le type de d√©pense.

üîç TYPE DE DOCUMENT (OBLIGATOIRE - choisis le plus appropri√©) :
- "invoice" : Facture commerciale avec montant √† payer et num√©ro de facture
- "receipt" : Re√ßu/ticket de caisse confirmant un paiement d√©j√† effectu√©
- "terms_and_conditions" : Conditions g√©n√©rales, CGV, CGU, mentions l√©gales
- "pricing_sheet" : Grille tarifaire, bar√®me de prix, liste de tarifs
- "notification" : Notification, alerte, changement de service (sans montant d√ª)
- "contract" : Contrat, accord commercial, convention
- "other" : Autre type de document

‚ö†Ô∏è ATTENTION : Si le document contient UNIQUEMENT des tarifs/frais FUTURS (ex: "nos nouveaux tarifs", "grille tarifaire") 
   ‚Üí c'est un "pricing_sheet", PAS une facture !

üí≥ STATUT DE PAIEMENT (OBLIGATOIRE - analyse le document pour d√©terminer) :
- "paid" : Si le document indique "PAID", "PAY√â", "Payment received", "Re√ßu", ou si c'est un RE√áU (receipt)
- "unpaid" : Si c'est une FACTURE (invoice) sans indication de paiement, ou "UNPAID", "√Ä PAYER"
- "pending" : Si le document indique "En attente", "Pending", "Processing"
- "overdue" : Si la date d'√©ch√©ance (due_date) est d√©pass√©e et non pay√©

üìå R√àGLE SIMPLE :
- document_type = "receipt" ‚Üí payment_status = "paid" (un re√ßu = d√©j√† pay√©)
- document_type = "invoice" + aucune mention de paiement ‚Üí payment_status = "unpaid"
- document_type = "invoice" + "PAID" visible ‚Üí payment_status = "paid"

CAT√âGORIES COMPTABLES (si document_type = "invoice" ou "receipt") :
- "Salaires et charges sociales" : paie, cotisations sociales, URSSAF
- "Loyer et charges locales" : loyer bureau, charges immeuble, copropri√©t√©
- "Mati√®res premi√®res" : mat√©riaux, stocks, fournitures production
- "Services externes (comptable, avocat, consultant)" : honoraires professionnels
- "Mat√©riel informatique et logiciels" : ordinateurs, licences, SaaS, abonnements tech
- "Marketing et publicit√©" : campagnes pub, SEO, r√©seaux sociaux, communication
- "Transports et d√©placements" : carburant, p√©ages, billets train/avion, h√¥tels
- "√ânergie" : √©lectricit√©, gaz, eau
- "Entretien et r√©parations" : maintenance, r√©parations √©quipements
- "Assurances" : assurances professionnelles, RC, v√©hicules
- "Frais bancaires et financiers" : frais bancaires, int√©r√™ts, commissions
- "Fournitures de bureau" : papeterie, mobilier bureau
- "Sous-traitance" : prestations externes, freelances
- "T√©l√©communications" : t√©l√©phone, internet, mobile
- "Formation et d√©veloppement" : formations, s√©minaires, coaching
- "Taxes et cotisations" : taxes professionnelles, CFE, imp√¥ts
- "Amortissements" : amortissements comptables
- "Charges exceptionnelles" : charges non r√©currentes, impr√©vues

Retourne un JSON avec cette structure EXACTE:
{
  "document_type": "invoice|receipt|terms_and_conditions|pricing_sheet|notification|contract|other (OBLIGATOIRE)",
  "invoice_number": "num√©ro",
  "vendor_name": "nom fournisseur (√©metteur)",
  "category": "UNE DES CAT√âGORIES CI-DESSUS (si invoice/receipt, sinon null)",
  "invoice_date": "YYYY-MM-DD",
  "due_date": "YYYY-MM-DD ou null",
  "total_amount": nombre,
  "subtotal": nombre ou null,
  "tax_amount": nombre ou null,
  "tax_rate": nombre ou null,
  "currency": "EUR/USD/GBP",
  "vendor_address": "adresse fournisseur" ou null,
  "vendor_city": "ville fournisseur" ou null,
  "vendor_country": "pays fournisseur" ou null,
  "vendor_phone": "t√©l√©phone fournisseur" ou null,
  "vendor_email": "email fournisseur" ou null,
  "vendor_website": "site fournisseur" ou null,
  "customer_name": "nom du client (destinataire)" ou null,
  "customer_address": "adresse client" ou null,
  "customer_city": "ville client" ou null,
  "customer_country": "pays client" ou null,
  "customer_phone": "t√©l√©phone client" ou null,
  "customer_email": "email client" ou null,
  "customer_vat_number": "num√©ro TVA client" ou null,
  "payment_status": "paid|unpaid|pending|overdue (OBLIGATOIRE - d√©termine selon le contexte)",
  "payment_method": "m√©thode" ou null,
  "payment_date": "YYYY-MM-DD" ou null,
  "line_items": [{"description": "...", "quantity": 1, "unit_price": 10, "total": 10}] ou null,
  "vendor_logo_description": "description du logo visible en haut (ex: logo circulaire bleu avec texte blanc, ic√¥ne stylis√©e, etc.)" ou null,
  "vendor_logo_colors": ["#couleur1", "#couleur2"] (codes hex des couleurs principales du logo) ou null,
  "vendor_logo_text": "texte ou lettres visibles dans le logo" ou null,
  "confidence_score": 0-100
}

R√©ponds UNIQUEMENT avec le JSON, sans texte avant/apr√®s.`,
          attachments: [{ file_id: file.id, tools: [{ type: 'file_search' }] }],
        },
      ],
    });
    
    // Ex√©cuter l'assistant
    const run = await openai.beta.threads.runs.createAndPoll(thread.id, {
      assistant_id: assistant.id,
    });
    
    if (run.status === 'completed') {
      const messages = await openai.beta.threads.messages.list(thread.id);
      const responseMessage = messages.data[0];
      
      if (responseMessage.content[0].type === 'text') {
        const responseText = responseMessage.content[0].text.value;
        console.log(`üìÑ [GPT-4o] R√©ponse:`, responseText.substring(0, 500));
        
        // Parser le JSON
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          const data = JSON.parse(jsonMatch[0]);
          console.log(`‚úÖ [GPT-4o] Donn√©es extraites (confiance: ${data.confidence_score}%)`);
          
          // Nettoyer
          await openai.beta.assistants.del(assistant.id);
          await openai.files.del(file.id);
          
          return data;
        }
      }
    }
    
    throw new Error(`Assistant run failed: ${run.status}`);
  } catch (error) {
    console.error('‚ùå [GPT-4o] Erreur extraction:', error);
    throw new Error(`√âchec extraction GPT-4o: ${error}`);
  }
}

/**
 * Structure les donn√©es extraites avec GPT-4o
 */
async function structureDataWithGPT(ocrText: string, emailContext?: {
  from: string;
  subject: string;
  date: string;
}): Promise<Partial<ExtractedInvoiceData>> {
  console.log('ü§ñ [GPT-4o] Structuration des donn√©es...');
  
  const prompt = `Tu es un expert comptable sp√©cialis√© dans l'extraction de donn√©es de factures.

TEXTE EXTRAIT PAR OCR (peut contenir des erreurs):
${ocrText.substring(0, 15000)} 

${emailContext ? `
CONTEXTE EMAIL:
- Exp√©diteur: ${emailContext.from}
- Sujet: ${emailContext.subject}
- Date: ${emailContext.date}
` : ''}

T√ÇCHE:
Analyse ce texte et extrait TOUTES les informations de facture disponibles.
Retourne un JSON avec cette structure EXACTE:

{
  "invoice_number": "num√©ro de facture",
  "vendor_name": "nom du fournisseur/entreprise",
  "invoice_date": "YYYY-MM-DD",
  "due_date": "YYYY-MM-DD ou null",
  "total_amount": nombre (montant TTC),
  "subtotal": nombre (montant HT) ou null,
  "tax_amount": nombre (montant TVA) ou null,
  "tax_rate": nombre (taux TVA en %) ou null,
  "currency": "EUR/USD/GBP",
  "vendor_address": "adresse compl√®te" ou null,
  "vendor_city": "ville" ou null,
  "vendor_country": "pays" ou null,
  "vendor_phone": "t√©l√©phone" ou null,
  "vendor_email": "email" ou null,
  "vendor_website": "site web" ou null,
  "payment_status": "paid/unpaid/pending/overdue" ou null,
  "payment_method": "card/bank_transfer/paypal/etc" ou null,
  "payment_date": "YYYY-MM-DD ou null",
  "line_items": [
    {
      "description": "description du produit/service",
      "quantity": nombre,
      "unit_price": nombre,
      "total": nombre
    }
  ] ou null,
  "confidence_score": nombre entre 0-100 (ton niveau de confiance dans l'extraction)
}

R√àGLES IMPORTANTES:
1. Cherche TOUS les montants (Total, Subtotal, Tax, etc.)
2. Les dates doivent √™tre au format ISO: YYYY-MM-DD
3. Les montants doivent √™tre des NOMBRES (pas de symboles ‚Ç¨/$)
4. Si une info n'est pas trouv√©e, mets null (pas de string vide)
5. Pour line_items, extrait TOUTES les lignes de la facture
6. Le confidence_score doit refl√©ter la qualit√© du texte OCR et la clart√© des infos
7. Retourne UNIQUEMENT le JSON, sans texte avant/apr√®s

R√©ponds avec le JSON maintenant:`;

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: 'Tu es un expert en extraction de donn√©es de factures. Tu r√©ponds UNIQUEMENT avec du JSON valide, sans texte suppl√©mentaire.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.1, // Bas pour plus de coh√©rence
      max_tokens: 2000,
    });

    const responseText = completion.choices[0].message.content || '{}';
    console.log(`üìÑ [GPT-4o] R√©ponse brute:`, responseText.substring(0, 500));
    
    // Parser le JSON (avec gestion des markdown code blocks)
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const data = JSON.parse(jsonMatch[0]);
      console.log(`‚úÖ [GPT-4o] Donn√©es structur√©es avec confiance: ${data.confidence_score}%`);
      return data;
    } else {
      console.warn('‚ö†Ô∏è [GPT-4o] Pas de JSON trouv√© dans la r√©ponse');
      return { confidence_score: 0 };
    }
  } catch (error) {
    console.error('‚ùå [GPT-4o] Erreur structuration:', error);
    throw new Error(`√âchec GPT-4o: ${error}`);
  }
}

/**
 * FONCTION PRINCIPALE : Extrait les donn√©es compl√®tes d'une facture
 * Utilise l'API Assistants d'OpenAI pour lire directement le PDF
 */
export async function extractInvoiceData(
  pdfBuffer: Buffer,
  emailContext?: {
    from: string;
    subject: string;
    date: string;
  }
): Promise<ExtractedInvoiceData> {
  console.log('\nüöÄ [EXTRACTION] D√©but du processus complet...');
  
  try {
    // Extraction directe avec GPT-4o (lit le PDF nativement)
    const structuredData = await extractDataDirectlyFromPDF(pdfBuffer, emailContext);
    
    // D√©terminer le statut d'extraction
    const confidenceScore = structuredData.confidence_score || 0;
    let extraction_status: 'success' | 'partial' | 'failed' = 'failed';
    
    if (confidenceScore >= 80) {
      extraction_status = 'success';
    } else if (confidenceScore >= 50) {
      extraction_status = 'partial';
    }
    
    console.log(`‚úÖ [EXTRACTION] Termin√© avec statut: ${extraction_status} (${confidenceScore}%)`);
    
    return {
      ...structuredData,
      extraction_status,
      confidence_score: confidenceScore,
      ocr_text: '', // Pas d'OCR dans cette approche
    } as ExtractedInvoiceData;
    
  } catch (error) {
    console.error('‚ùå [EXTRACTION] Erreur fatale:', error);
    
    return {
      invoice_number: null,
      vendor_name: emailContext?.from || null,
      invoice_date: emailContext?.date || null,
      due_date: null,
      total_amount: null,
      subtotal: null,
      tax_amount: null,
      tax_rate: null,
      currency: null,
      vendor_address: null,
      vendor_city: null,
      vendor_country: null,
      vendor_phone: null,
      vendor_email: null,
      vendor_website: null,
      payment_status: null,
      payment_method: null,
      payment_date: null,
      line_items: null,
      extraction_status: 'failed',
      confidence_score: 0,
      ocr_text: '',
    };
  }
}

